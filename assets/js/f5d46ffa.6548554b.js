"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[1249],{4821:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var s=i(5893),t=i(1151);const r={},a="Basics of using a Terminal",l={id:"hpc-tutorials/linux-introduction/using-a-terminal",title:"Basics of using a Terminal",description:"In this section, we will use Ubuntu 22.04 as our Linux distro. First, we will discuss the basic aspects of using a Linux terminal.",source:"@site/docs/02-hpc-tutorials/01-linux-introduction/02-using-a-terminal.md",sourceDirName:"02-hpc-tutorials/01-linux-introduction",slug:"/hpc-tutorials/linux-introduction/using-a-terminal",permalink:"/docs/hpc-tutorials/linux-introduction/using-a-terminal",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Choosing an OS",permalink:"/docs/hpc-tutorials/linux-introduction/choosing-an-os"},next:{title:"SSH",permalink:"/docs/hpc-tutorials/linux-introduction/ssh"}},o={},c=[{value:"Interacting with the Filesystem",id:"interacting-with-the-filesystem",level:2},{value:"Environment variables",id:"environment-variables",level:2},{value:"Printing Environment Variables",id:"printing-environment-variables",level:3},{value:"Environment Variable Scope",id:"environment-variable-scope",level:3},{value:"Limited Scope",id:"limited-scope",level:3},{value:"Pass Environment Variables",id:"pass-environment-variables",level:3},{value:"Export Environment Variables",id:"export-environment-variables",level:3},{value:"Removing Environment Variables",id:"removing-environment-variables",level:3},{value:"Common Environment Variables",id:"common-environment-variables",level:3},{value:"Bashrc: Saving Environment Variables",id:"bashrc-saving-environment-variables",level:3},{value:"Simple text editing",id:"simple-text-editing",level:2},{value:"Nano",id:"nano",level:3},{value:"Vim",id:"vim",level:3}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"basics-of-using-a-terminal",children:"Basics of using a Terminal"}),"\n",(0,s.jsx)(n.p,{children:"In this section, we will use Ubuntu 22.04 as our Linux distro. First, we will discuss the basic aspects of using a Linux terminal."}),"\n",(0,s.jsx)(n.p,{children:"A terminal provides a way of interacting with the OS using a command prompt. Users enter commands into the terminal based on memory\ninstead of using a graphical user interface (GUI). This can be faster since it avoids clicking and memorizing menus. However, it is\nalso necessary since many HPC machines are remote and do not support fancy GUIs. There are many commands Linux users should be\nfamiliar with in general."}),"\n",(0,s.jsx)(n.h2,{id:"interacting-with-the-filesystem",children:"Interacting with the Filesystem"}),"\n",(0,s.jsx)(n.p,{children:"Examples of the basic filesystem operations are as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Change directory to your home directory\n# ~/ is shorthand for home directory\n# ~ is a special character used by the terminal\ncd ~/\n\n# Create a directory\nmkdir hello\n\n# Create directories + subdirectories\nmkdir -p hello/hi/hi2\n\n# Change into the "hello" directory\n# cd: "change directory"\ncd hello\n\n# Create 4 empty files\ntouch hi.txt\ntouch hi2.txt\ntouch hi3.txt hi4.txt\n\n# List the hello directory (view its contents)\nls hello\n\n# Change into the "hi2" directory\n# NOTE: ./ is optional\n# cd hi/hi2 would do the same thing\ncd ./hi/hi2\n\n# Go to the parent directory (hi)\ncd ..\n# Go to hello\'s parent\ncd ../../\n\n# Remove 3 of the files\n# NOTE: rm is permanent, data recovery is not really possible\nrm hello/hi.txt\nrm hello/hi2.txt hello/hi3.txt\n\n# Remove directories and subdirectories\n# "r" means to "recursively" delete all data in the directory\n# "f" means "force" delete the directory without asking for confirmation\nrm -rf hello\n\n# Append a string to a file\n# >> is the append operator\n# hello.txt contains 2525\necho "25" >> hello.txt\necho "25" >> hello.txt\n\n# Create a new file with string as its data\n# > truncates a file and replaces its text with the echo\'d string\n# hello.txt contains 30\necho "30" > hello.txt\n'})}),"\n",(0,s.jsx)(n.h2,{id:"environment-variables",children:"Environment variables"}),"\n",(0,s.jsx)(n.p,{children:"Environment variables are used to store some sort of information without having to hard-code it each time.\nMany programs rely on environment variables as a way of passing information to the program."}),"\n",(0,s.jsx)(n.h3,{id:"printing-environment-variables",children:"Printing Environment Variables"}),"\n",(0,s.jsx)(n.p,{children:"To set an environment variable and print it, run:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"MY_VAR=25\necho ${MY_VAR}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"25\n"})}),"\n",(0,s.jsx)(n.h3,{id:"environment-variable-scope",children:"Environment Variable Scope"}),"\n",(0,s.jsx)(n.p,{children:"Scope refers to the visibility of a variable. For example, can a program read the environment variable after it has been set?"}),"\n",(0,s.jsxs)(n.p,{children:["Let's say we have the following bash script named ",(0,s.jsx)(n.code,{children:"printenv.sh"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"#!/bin/bash\n\necho ${MY_VAR}\n"})}),"\n",(0,s.jsx)(n.p,{children:"To use this bash script, run:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd ${SCS_TUTORIAL}/1.1.linux_intro\n"})}),"\n",(0,s.jsx)(n.h3,{id:"limited-scope",children:"Limited Scope"}),"\n",(0,s.jsx)(n.p,{children:"Run the following code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"MY_VAR=25\nbash printenv.sh\n"})}),"\n",(0,s.jsx)(n.p,{children:"Output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash"})}),"\n",(0,s.jsxs)(n.p,{children:["The output is empty. This is because the scope of ",(0,s.jsx)(n.code,{children:"MY_VAR"})," is limited to the current shell. When launching ",(0,s.jsx)(n.code,{children:"printenv.sh"}),",\na new shell is created and the variable ",(0,s.jsx)(n.code,{children:"MY_VAR"})," is not passed to it."]}),"\n",(0,s.jsx)(n.h3,{id:"pass-environment-variables",children:"Pass Environment Variables"}),"\n",(0,s.jsx)(n.p,{children:"To pass environment variables to programs, run the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"MY_VAR=25\nMY_VAR=20 bash printenv.sh\necho ${MY_VAR}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"20\n25\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, ",(0,s.jsx)(n.code,{children:"MY_VAR=20"})," is passed to ",(0,s.jsx)(n.code,{children:"printenv.sh"}),", which then prints ",(0,s.jsx)(n.code,{children:"20"}),". However, ",(0,s.jsx)(n.code,{children:"MY_VAR=20"})," does not change the\nvalue of ",(0,s.jsx)(n.code,{children:"MY_VAR"})," in the parent shell. Running ",(0,s.jsx)(n.code,{children:"echo ${MY_VAR}"})," prints ",(0,s.jsx)(n.code,{children:"25"}),", which was the original value."]}),"\n",(0,s.jsx)(n.h3,{id:"export-environment-variables",children:"Export Environment Variables"}),"\n",(0,s.jsx)(n.p,{children:"Exporting an environment variables modifies the value of the variable in the current shell and passes the variable to\nprograms executed in the shell."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"export MY_VAR=20\nbash printenv.sh\necho ${MY_VAR}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"20\n"})}),"\n",(0,s.jsx)(n.h3,{id:"removing-environment-variables",children:"Removing Environment Variables"}),"\n",(0,s.jsx)(n.p,{children:"To remove an environment variable:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"unset MY_VAR\nbash printenv.sh\n"})}),"\n",(0,s.jsx)(n.p,{children:"Output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash"})}),"\n",(0,s.jsx)(n.h3,{id:"common-environment-variables",children:"Common Environment Variables"}),"\n",(0,s.jsx)(n.p,{children:"Below we describe some environment variables that come automatically when you open a terminal:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# HOME represents your home directory\necho "HOME=${HOME}"\ncd ${HOME}\n# PWD stands for print working directory\n# Output will be equivalent to ${HOME} in this case\necho "PWD=${PWD}"\n# USER represents your username\necho "USER=${USER}"\n'})}),"\n",(0,s.jsx)(n.p,{children:"This list is not comprehensive, and there are many more variables that are important -- but they will\nbe discussed later."}),"\n",(0,s.jsx)(n.h3,{id:"bashrc-saving-environment-variables",children:"Bashrc: Saving Environment Variables"}),"\n",(0,s.jsxs)(n.p,{children:["In your home directory, there is a file called ",(0,s.jsx)(n.code,{children:"~/.bashrc"}),". This file is executed every time you open a shell.\nThis file can be used for storing environment variables."]}),"\n",(0,s.jsx)(n.p,{children:"Bashrc contains a bunch of code. This code is used to initialize the state of a shell. Typically it's best to\nplace environment variables at the bottom of the bashrc file. This can be done as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'echo "export MY_VAR=30" >> ~/.bashrc\n'})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'echo "MY_VAR=25"'})," will print the string ",(0,s.jsx)(n.code,{children:'"MY_VAR=25"'}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:">>"})," will append the string ",(0,s.jsx)(n.code,{children:'"MY_VAR=25"'})," to ",(0,s.jsx)(n.code,{children:"~/.bashrc"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you open ~/.bashrc you should see at the bottom of the file is that export statement."}),"\n",(0,s.jsx)(n.p,{children:"Note, appending the export statement does NOT rerun the bashrc script. Your current shell will not be updated yet.\nTo execute the bashrc script and update the current shell, run:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"source ~/.bashrc\necho ${MY_VAR}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Output:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"30\n"})}),"\n",(0,s.jsx)(n.h2,{id:"simple-text-editing",children:"Simple text editing"}),"\n",(0,s.jsx)(n.p,{children:"There are three main terminal text editors: nano, vim, and emacs. vim and emacs rely heavily on memorizing key bindings.\nFor new users, this is typically challenging. In general, we do not code using terminal text editors, we only use them to\ndo minor changes. We recommend that large changes to files be made in an IDE, office tool, or graphical text editor."}),"\n",(0,s.jsx)(n.p,{children:"For this reason, we will discuss only the basics of vim and nano. We will not touch emacs, as vim and nano are almost\nalways the default text editors. Generally, we recommend nano since it's simple. Some cases, vim may be the default,\nso it will be discussed too."}),"\n",(0,s.jsx)(n.h3,{id:"nano",children:"Nano"}),"\n",(0,s.jsx)(n.p,{children:"To open or create a file using nano, do the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"nano ~/hello.txt\n"})}),"\n",(0,s.jsx)(n.p,{children:"The file can be edited immediately (if you have edit rights to the file)."}),"\n",(0,s.jsx)(n.p,{children:"The main keybindings to be aware of are as follows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:['"',(0,s.jsx)("kbd",{children:"Ctrl"})," ",(0,s.jsx)("kbd",{children:"s"}),'" will save a file']}),"\n",(0,s.jsxs)(n.li,{children:['"',(0,s.jsx)("kbd",{children:"Ctrl"})," ",(0,s.jsx)("kbd",{children:"x"}),'" will close the file']}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["NOTE: ",(0,s.jsx)(n.code,{children:"nano"})," does not come by default on every single machine. You may have to install separately."]}),"\n",(0,s.jsx)(n.h3,{id:"vim",children:"Vim"}),"\n",(0,s.jsx)(n.p,{children:"To open a file using vim, do the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"vi ~/hello.txt\n"})}),"\n",(0,s.jsx)(n.p,{children:"When the file is opened, the main keybindings to consider are is follows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:['Initially, the file is opened in "normal mode". ',(0,s.jsxs)(n.strong,{children:['You must press "',(0,s.jsx)("kbd",{children:"i"}),'" in order to switch to "edit mode"']}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["When you have finished editing, press ",(0,s.jsx)("kbd",{children:"ESC"})," on your keyboard. This will bring you back to normal mode"]}),"\n",(0,s.jsxs)(n.li,{children:["Press ",(0,s.jsx)("kbd",{children:":"}),' to bring you into "command mode"']}),"\n",(0,s.jsx)(n.li,{children:'Then type "wq" to "write" and then "quit". Press enter, and the editor will close'}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:['NOTE: if you accidentally press "',(0,s.jsx)("kbd",{children:"Ctrl"})," ",(0,s.jsx)("kbd",{children:"s"}),'", you will not be able to type anything (not even commands).\nTo get out of this, type "',(0,s.jsx)("kbd",{children:"Ctrl"})," ",(0,s.jsx)("kbd",{children:"q"}),'"']})]})}function d(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>a});var s=i(7294);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);