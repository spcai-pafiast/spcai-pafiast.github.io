"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[6238],{7314:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var r=n(5893),t=n(1151);const a={},i="Runtime",o={id:"hermes/components/runtime",title:"Runtime",description:"Hermes is built as a plugin to the Hermes Runtime, a distributed task processing framework",source:"@site/docs/03-hermes/06-components/07-runtime.md",sourceDirName:"03-hermes/06-components",slug:"/hermes/components/runtime",permalink:"/docs/hermes/components/runtime",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Data Staging",permalink:"/docs/hermes/components/data-staging"},next:{title:"Distributed Metadata",permalink:"/docs/hermes/components/distributed-metadata"}},l={},c=[{value:"Task Repos and Task Libraries",id:"task-repos-and-task-libraries",level:2},{value:"Bootstrapping a Task Library",id:"bootstrapping-a-task-library",level:2},{value:"Overview of Bootstrapped Code",id:"overview-of-bootstrapped-code",level:3},{value:"CreateTask",id:"createtask",level:3},{value:"Task Struct",id:"task-struct",level:4},{value:"Task Client",id:"task-client",level:4},{value:"Task Server",id:"task-server",level:4},{value:"DestructTask",id:"destructtask",level:3},{value:"Overview of Task Submission and Queueing",id:"overview-of-task-submission-and-queueing",level:2},{value:"Creating Custom Tasks",id:"creating-custom-tasks",level:2},{value:"Modify <code>compress_methods.yaml</code>",id:"modify-compress_methodsyaml",level:3},{value:"Modify <code>compress_tasks.h</code>",id:"modify-compress_tasksh",level:3},{value:"The <code>TaskFlags</code> base class",id:"the-taskflags-base-class",level:4},{value:"Task Constructor",id:"task-constructor",level:4},{value:"Modify <code>compress.cc</code>",id:"modify-compresscc",level:3},{value:"Modify <code>compress.h</code>",id:"modify-compressh",level:3},{value:"Task Methods",id:"task-methods",level:3},{value:"Registering a Task Library",id:"registering-a-task-library",level:2},{value:"Task Grouping, Worker Polling, and Deadlock Prevention",id:"task-grouping-worker-polling-and-deadlock-prevention",level:2},{value:"Building a Replicatable Task",id:"building-a-replicatable-task",level:2},{value:"Building a Data-Intensive, RDMA-Capable Task",id:"building-a-data-intensive-rdma-capable-task",level:2}];function d(e){const s={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h1,{id:"runtime",children:"Runtime"}),"\n",(0,r.jsx)(s.p,{children:"Hermes is built as a plugin to the Hermes Runtime, a distributed task processing framework\r\ncapable of scheduling, replicating, distributing, processing, monitoring, and\r\nload balancing arbitrary tasks. Tasks define various properties which provide\r\ncontrol over scheduling decisions, memory management, and concurrency.\r\nThis section will discuss the design of the Hermes Runtime and how to develop\r\ncustom tasks."}),"\n",(0,r.jsx)(s.h2,{id:"task-repos-and-task-libraries",children:"Task Repos and Task Libraries"}),"\n",(0,r.jsxs)(s.p,{children:["The Hermes Runtime is used for executing arbitrary tasks. Developers can create\r\nnew tasks and release them using a decentralized package management design,\r\nsimilar to spack. This is accomplished through ",(0,r.jsx)(s.strong,{children:"task repos"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["A task repo is a directory which contains a set of ",(0,r.jsx)(s.strong,{children:"task libraries"}),". A\r\ntask library (or lib) provides the functionality to submit and execute tasks.\r\nTask libs follow the single responsibility principle. Multiple task libs should\r\nbe created to separate unrelated or loosely related functionality."]}),"\n",(0,r.jsx)(s.p,{children:'For example, the Hermes Runtime has a task repo named "tasks_required" located under the hrun directory of the Hermes repo.'}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"tasks_required\r\n\u251c\u2500\u2500 CMakeLists.txt\r\n\u251c\u2500\u2500 hrun_admin\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 CMakeLists.txt\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 include\r\n\u2502\xa0\xa0 \u2514\u2500\u2500 src\r\n\u251c\u2500\u2500 proc_queue\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 CMakeLists.txt\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 include\r\n\u2502\xa0\xa0 \u2514\u2500\u2500 src\r\n\u251c\u2500\u2500 remote_queue\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 CMakeLists.txt\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 include\r\n\u2502\xa0\xa0 \u2514\u2500\u2500 src\r\n\u251c\u2500\u2500 small_message\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 CMakeLists.txt\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 include\r\n\u2502\xa0\xa0 \u2514\u2500\u2500 src\r\n\u251c\u2500\u2500 TASK_NAME\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 CMakeLists.txt\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 include\r\n\u2502\xa0\xa0 \u2514\u2500\u2500 src\r\n\u251c\u2500\u2500 worch_proc_round_robin\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 CMakeLists.txt\r\n\u2502\xa0\xa0 \u251c\u2500\u2500 include\r\n\u2502\xa0\xa0 \u2514\u2500\u2500 src\r\n\u2514\u2500\u2500 worch_queue_round_robin\r\n    \u251c\u2500\u2500 CMakeLists.txt\r\n    \u251c\u2500\u2500 include\r\n    \u2514\u2500\u2500 src\n"})}),"\n",(0,r.jsx)(s.p,{children:"The tasks_required directory contains tasks which are required for the Hermes Runtime to function. These tasks are non-negotiable and will always be registered automatically by the runtime."}),"\n",(0,r.jsx)(s.h2,{id:"bootstrapping-a-task-library",children:"Bootstrapping a Task Library"}),"\n",(0,r.jsx)(s.p,{children:"A Task Library implements the following concepts:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Task"}),": A struct containing the parameters to execute"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Task Server"}),": A class responsible for executing tasks. This is\r\nreleased as a shared object."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Task Client"}),": A class responsible for submitting tasks to the hermes runtime. This is released as a header file, which is included by the client program."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:['To easily bootstrap a task lib, Hermes provides a python-based code generator called make_task. This script assumes a Linux system at this time (Windows has a different pathing system). Let\'s say you want to create a new task lib named "compress" for creating a factory of compression libraries. The task lib is located in the task repo ',(0,r.jsx)(s.code,{children:"${HOME}/my_task_repo"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"codegen/make_task ${HOME}/my_task_repo/compress\n"})}),"\n",(0,r.jsx)(s.p,{children:"This will create a task lib with the following directory structure:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"compress\r\n\u251c\u2500\u2500 CMakeLists.txt\r\n\u251c\u2500\u2500 include\r\n\u2502\xa0\xa0 \u2514\u2500\u2500 compress\r\n\u2502\xa0\xa0     \u251c\u2500\u2500 compress.h\r\n\u2502\xa0\xa0     \u251c\u2500\u2500 compress_lib_exec.h\r\n\u2502\xa0\xa0     \u251c\u2500\u2500 compress_methods.h\r\n\u2502\xa0\xa0     \u251c\u2500\u2500 compress_methods.yaml\r\n\u2502\xa0\xa0     \u2514\u2500\u2500 compress_tasks.h\r\n\u2514\u2500\u2500 src\r\n    \u251c\u2500\u2500 CMakeLists.txt\r\n    \u2514\u2500\u2500 compress.cc\n"})}),"\n",(0,r.jsx)(s.p,{children:"The main files to edit:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"include/compress/compress.h"}),":\r\nThis is the ",(0,r.jsx)(s.strong,{children:"Task Client"}),". User applications (e.g., VPIC, WRF) include this file and use it to submit tasks to the Hermes Runtime."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"include/compress/compress_methods.yaml"}),":\r\nDefines the name of all methods that will be implemented in the ",(0,r.jsx)(s.strong,{children:"Task Server"}),". This file will be converted into an enumeration."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"include/compress/compress_tasks.h"}),":\r\nDefines the ",(0,r.jsx)(s.strong,{children:"Tasks"})," that can be constructed. Tasks are implemented as structs that are compatible with shared memory.\r\nTasks will only implement methods to serialize and copy the task. The actual function of the task is implemented\r\nin the Task Server."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"src/compress/compress.cc"}),":\r\nThis is the ",(0,r.jsx)(s.strong,{children:"Task Server"}),". This file will be compiled into a shared object that can be dynamically loaded by the runtime. The task server must include handlers which take as input a task struct and then run a function over it."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Files that are automatically generated:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"include/compress/compress_lib_exec.h"}),":\r\nThis is included in ",(0,r.jsx)(s.code,{children:"compress.cc"})," automatically.\r\nThis is an internal file not meant to be included anywhere else.\r\nThis file produces code to route tasks to functions in compress.cc."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"include/compress/compress_methods.h"}),":\r\nThis defines an enumeration containing all methods defined\r\nin compress_methods.yaml. It is included automatically by ",(0,r.jsx)(s.code,{children:"compress_tasks.h"})]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"overview-of-bootstrapped-code",children:"Overview of Bootstrapped Code"}),"\n",(0,r.jsx)(s.p,{children:"The bootstrap method will create a task library with the following methods: Create, Destruct, and Custom. Create and Destruct are required\r\nby all Task Libraries and should not be removed. Custom is optional and provides an overview of the methods available to you for creating custom tasks. The code generated can be compiled immediately by adding it as a subdirectory to the root CMake of the task repo."}),"\n",(0,r.jsx)(s.h3,{id:"createtask",children:"CreateTask"}),"\n",(0,r.jsx)(s.p,{children:"CreateTask is responsible for initially registering a task state in the Hermes Runtime. This is analgous to class constructors."}),"\n",(0,r.jsx)(s.h4,{id:"task-struct",children:"Task Struct"}),"\n",(0,r.jsxs)(s.p,{children:["In ",(0,r.jsx)(s.code,{children:"include/compress/compress_tasks.h"})]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:'using hrun::Admin::CreateTaskStateTask;\r\nstruct ConstructTask : public CreateTaskStateTask {\r\n  /** SHM default constructor */\r\n  HSHM_ALWAYS_INLINE explicit\r\n  ConstructTask(hipc::Allocator *alloc)\r\n  : CreateTaskStateTask(alloc) {}\r\n\r\n  /** Emplace constructor */\r\n  HSHM_ALWAYS_INLINE explicit\r\n  ConstructTask(hipc::Allocator *alloc,\r\n                const TaskNode &task_node,\r\n                const DomainId &domain_id,\r\n                const std::string &state_name,\r\n                const TaskStateId &id,\r\n                const std::vector<PriorityInfo> &queue_info)\r\n      : CreateTaskStateTask(alloc, task_node, domain_id, state_name,\r\n                            "compress", id, queue_info) {\r\n    // Custom params\r\n  }\r\n\r\n  HSHM_ALWAYS_INLINE\r\n  ~ConstructTask() {\r\n    // Custom params\r\n  }\r\n};\n'})}),"\n",(0,r.jsx)(s.p,{children:"This file defines the task struct that will be communicated between clients and the runtime. This task must always include a minimum of the above parameters. The order of parameters\r\nshould not be changed. Any additional parameters should be appended after queue_info."}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"alloc"}),": The shared-memory allocator the task was allocated with"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"task_node"}),': Tasks can spawn subtasks. This ability we refer to as Task Graphs. TaskNode stores the root of the Task Graph and the depth of this task in the Task Graph. For "Root" tasks, the TaskNode will be the unique ID of the task with a depth of 0.']}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"domain_id"}),": Tasks can be scheduled or replicated over a domain of nodes. A domain is analogous to an MPI communicator. However, domains theoretically support dynamic node registration, unlike MPI."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"state_name"}),": This is a semantic, unique, user-defined name to give the state. The state can be queried using this name in the future."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"state_id"}),": This is a unique integer ID to give the state. This is an optional parameter that can be equal to null. When null, the state id is allocated automatically by the runtime and returned as the ",(0,r.jsx)(s.code,{children:"id_"})," parameter in the base class CreateTaskStateTask."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"queue_info"}),": Provides control over the queue to spawn to interact with this state. Each task state"]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"task-client",children:"Task Client"}),"\n",(0,r.jsxs)(s.p,{children:["In ",(0,r.jsx)(s.code,{children:"include/compress/compress.h"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"/** Async create a task state */\r\nHSHM_ALWAYS_INLINE\r\nLPointer<ConstructTask> AsyncCreate(const TaskNode &task_node,\r\n                                    const DomainId &domain_id,\r\n                                    const std::string &state_name) {\r\n  id_ = TaskStateId::GetNull();\r\n  QueueManagerInfo &qm = HRUN_CLIENT->server_config_.queue_manager_;\r\n  std::vector<PriorityInfo> queue_info = {\r\n      {1, 1, qm.queue_depth_, 0},\r\n      {1, 1, qm.queue_depth_, QUEUE_LONG_RUNNING},\r\n      {qm.max_lanes_, qm.max_lanes_, qm.queue_depth_, QUEUE_LOW_LATENCY}\r\n  };\r\n  return HRUN_ADMIN->AsyncCreateTaskState<ConstructTask>(\r\n      task_node, domain_id, state_name, id_, queue_info);\r\n}\r\nHRUN_TASK_NODE_ROOT(AsyncCreate)\r\ntemplate<typename ...Args>\r\nHSHM_ALWAYS_INLINE\r\nvoid CreateRoot(Args&& ...args) {\r\n  LPointer<ConstructTask> task =\r\n      AsyncCreateRoot(std::forward<Args>(args)...);\r\n  task->Wait();\r\n  id_ = task->id_;\r\n  queue_id_ = QueueId(id_);\r\n  HRUN_CLIENT->DelTask(task);\r\n}\n"})}),"\n",(0,r.jsxs)(s.p,{children:["This code is called in client programs, such as VPIC, HACC, etc. ",(0,r.jsx)(s.code,{children:"CreateRoot"})," calls ",(0,r.jsx)(s.code,{children:"AsyncCreateRoot"}),", which will allocate, construct, and enqueue the CreateTask. ",(0,r.jsx)(s.code,{children:"HRUN_TASK_NODE_ROOT"}),' is a macro that creates the\r\nAsyncCreateRoot method. The "Root" suffix implies that the method\r\nis going to spawn a task that represents the root of a Task Graph.\r\nThis distinction is needed for avoiding potential deadlocks and\r\nconsistency problems.']}),"\n",(0,r.jsx)(s.h4,{id:"task-server",children:"Task Server"}),"\n",(0,r.jsxs)(s.p,{children:["In ",(0,r.jsx)(s.code,{children:"src/compress.cc"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"void Construct(ConstructTask *task, RunContext &rctx) {\r\n  task->SetModuleComplete();\r\n}\n"})}),"\n",(0,r.jsx)(s.p,{children:"This is the method that the ConstructTask will be routed to."}),"\n",(0,r.jsx)(s.h3,{id:"destructtask",children:"DestructTask"}),"\n",(0,r.jsxs)(s.p,{children:["The destruct task is responsible for releasing the Task State when the runtime is shutting down or when the user intentionally frees it. The DestructTask defined in ",(0,r.jsx)(s.code,{children:"compress_tasks.h"})," should never be modified, and is the same across all tasks. It should not take additional parameters since the runtime shutdown process will fail."]}),"\n",(0,r.jsx)(s.h2,{id:"overview-of-task-submission-and-queueing",children:"Overview of Task Submission and Queueing"}),"\n",(0,r.jsx)(s.p,{children:"Communication with the Hermes Runtime is accomplished through queueing.\r\nThe data structure is termed MultiQueue. The MultiQueue is a shared-memory, lock-free, concurrent priority queue. For each Task State,\r\nan associated MultiQueue will be created. MultiQueues are defined\r\nby a vector of PriorityInfo structs."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"struct PriorityInfo {\r\n  u32 max_lanes_;       /**< Maximum number of lanes in the queue */\r\n  u32 num_lanes_;       /**< Current number of lanes in use */\r\n  u32 depth_;           /**< The maximum depth of individual lanes */\r\n  bitfield32_t flags_;  /**< Scheduling hints for the queue */\r\n};\n"})}),"\n",(0,r.jsx)(s.p,{children:"A lane is a multiple-producer, single-consumer lock-free shared memory\r\nqueue. Each lane is scheduled on workers independently. A lane represents\r\nthe unit of concurrency in the Hermes Runtime."}),"\n",(0,r.jsxs)(s.p,{children:["In ",(0,r.jsx)(s.code,{children:"include/compress/compress.h"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"/** Async create a task state */\r\nHSHM_ALWAYS_INLINE\r\nLPointer<ConstructTask> AsyncCreate(const TaskNode &task_node,\r\n                                    const DomainId &domain_id,\r\n                                    const std::string &state_name) {\r\n  id_ = TaskStateId::GetNull();\r\n  QueueManagerInfo &qm = HRUN_CLIENT->server_config_.queue_manager_;\r\n  std::vector<PriorityInfo> queue_info = {\r\n      {1, 1, qm.queue_depth_, 0},\r\n      {1, 1, qm.queue_depth_, QUEUE_LONG_RUNNING},\r\n      {qm.max_lanes_, qm.max_lanes_, qm.queue_depth_, QUEUE_LOW_LATENCY}\r\n  };\r\n  return HRUN_ADMIN->AsyncCreateTaskState<ConstructTask>(\r\n      task_node, domain_id, state_name, id_, queue_info);\r\n}\n"})}),"\n",(0,r.jsx)(s.p,{children:"This will create a MultiQueue with three priorities. Each element of\r\nthe vector is a Priority. Priority 0 will contain a single lane with\r\nthe user-configured default queue depth. Priority 1 will also\r\nbe a single lane, but with QUEUE_LONG_RUNNING flag. Tasks in these\r\nlanes will be scheduled on diferent workers for QUEUE_LOW_LATENCY\r\nlanes for performance reasons."}),"\n",(0,r.jsx)(s.h2,{id:"creating-custom-tasks",children:"Creating Custom Tasks"}),"\n",(0,r.jsx)(s.p,{children:"Now that the task library has been bootstrapped, this section will go over how to add new tasks."}),"\n",(0,r.jsxs)(s.h3,{id:"modify-compress_methodsyaml",children:["Modify ",(0,r.jsx)(s.code,{children:"compress_methods.yaml"})]}),"\n",(0,r.jsx)(s.p,{children:"Initially, the file contains:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"kCustom: 0\n"})}),"\n",(0,r.jsx)(s.p,{children:"For compression, let's say we want to have two methods: Compress and\r\nDecompress. We would modify this file to contain the following:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"kCompress: 0\r\nkDecompress: 1\n"})}),"\n",(0,r.jsx)(s.p,{children:"We then need to refresh the methods in this repo. This will autogenerate\r\ncode needed by the runtime to route tasks to these functions. This\r\nis accomplished through the refresh_methods code generator:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"codegen/refresh_methods ${HOME}/my_task_repo\n"})}),"\n",(0,r.jsx)(s.p,{children:"This will refresh all methods in the my_task_repo. This should be\r\na very fast operation, so it just does it for all tasks in the\r\ndirectory to avoid specifying a specific task library."}),"\n",(0,r.jsxs)(s.h3,{id:"modify-compress_tasksh",children:["Modify ",(0,r.jsx)(s.code,{children:"compress_tasks.h"})]}),"\n",(0,r.jsx)(s.p,{children:"Let's add the following task for representing the compression method."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"struct CompressTask : public Task, TaskFlags<TF_SRL_SYM> {\r\n  IN int compress_method_;\r\n  IN hipc::ShmArchive<hipc::string> data_;\r\n\r\n  /** SHM default constructor */\r\n  HSHM_ALWAYS_INLINE explicit\r\n  CompressTask(hipc::Allocator *alloc) : Task(alloc) {}\r\n\r\n  /** Emplace constructor */\r\n  HSHM_ALWAYS_INLINE explicit\r\n  CompressTask(hipc::Allocator *alloc,\r\n             const TaskNode &task_node,\r\n             const DomainId &domain_id,\r\n             const TaskStateId &state_id,\r\n             int compress_method,\r\n             const std::string &data) : Task(alloc) {\r\n    // Initialize task\r\n    task_node_ = task_node;\r\n    lane_hash_ = 0;\r\n    prio_ = TaskPrio::kLowLatency;\r\n    task_state_ = state_id;\r\n    method_ = Method::kCustom;\r\n    task_flags_.SetBits(TASK_UNORDERED | TASK_LANE_ANY);\r\n    domain_id_ = domain_id;\r\n\r\n    // Custom params\r\n    compress_method_ = compress_method;\r\n    HSHM_MAKE_AR(data_, alloc, data);\r\n  }\r\n\r\n  /** (De)serialize message call */\r\n  template<typename Ar>\r\n  void SerializeStart(Ar &ar) {\r\n    task_serialize<Ar>(ar);\r\n    ar(compress_method_, data_);\r\n  }\r\n\r\n  /** (De)serialize message return */\r\n  template<typename Ar>\r\n  void SerializeEnd(u32 replica, Ar &ar) {\r\n  }\r\n\r\n  /** Create group */\r\n  HSHM_ALWAYS_INLINE\r\n  u32 GetGroup(hshm::charbuf &group) {\r\n    return TASK_UNORDERED;\r\n  }\r\n};\n"})}),"\n",(0,r.jsxs)(s.h4,{id:"the-taskflags-base-class",children:["The ",(0,r.jsx)(s.code,{children:"TaskFlags"})," base class"]}),"\n",(0,r.jsx)(s.p,{children:"The CompressTask inherits from TaskFlags, which defines compile-time\r\nproperties of the task -- particularly the class methods."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"struct CompressTask : public Task, TaskFlags<TF_SRL_SYM> {\r\n// };\n"})}),"\n",(0,r.jsx)(s.p,{children:"Here, the TaskFlags has the parameter TF_SRL_SYM. This constant implies\r\nthe task supports serialization methods. These methods will be called\r\ninternally when a task gets dispersed to remote nodes."}),"\n",(0,r.jsx)(s.p,{children:"SerializeStart is called when a task is being shipped to a remote\r\nnode for execution. SerializeEnd is called when returning from\r\nthe remote node. In this way, the task can store both the input\r\nand output of the operation performed. This avoids having a separate\r\ncompletion queue."}),"\n",(0,r.jsx)(s.p,{children:"There are a few kinds of tasks:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"TF_LOCAL: tasks that execute only on the local node. They cannot\r\nbe shipped to remote nodes and they cannot be replicated."}),"\n",(0,r.jsx)(s.li,{children:"TF_SRL_SYM: tasks that execute potentially on a remote node. They\r\ncannot be replicated. Must implement SerializeStart and SerializeEnd."}),"\n",(0,r.jsx)(s.li,{children:"TF_SRL_SYM | TF_REPLICA: tasks that can be shipped to a remote node\r\nand support replication. Must implement ReplicateStart, ReplicateEnd, Dup, DupEnd."}),"\n",(0,r.jsx)(s.li,{children:"TF_SRL_ASYM_START: task has asymmetric serialization and deserialization methods for input variables (SaveStart, LoadStart instead of SerializeStart)"}),"\n",(0,r.jsx)(s.li,{children:"TF_SRL_ASYM_END: task has asymmetric serialization and deserialization methods for output variables (SaveEnd, LoadEnd instead of SerializeEnd)"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"TODO: explain what each candidate method does"}),"\n",(0,r.jsx)(s.h4,{id:"task-constructor",children:"Task Constructor"}),"\n",(0,r.jsx)(s.p,{children:"We will provide a brief overview of an example implementaion of CompressTask. DecompressTask looks similar, so we don't repeat."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"/** Emplace constructor */\r\nHSHM_ALWAYS_INLINE explicit\r\nCompressTask(hipc::Allocator *alloc,\r\n           const TaskNode &task_node,\r\n           const DomainId &domain_id,\r\n           const TaskStateId &state_id,\r\n           int compress_method,\r\n           const std::string &data) : Task(alloc) {\r\n  // Initialize task\r\n  task_node_ = task_node;\r\n  lane_hash_ = 0;\r\n  prio_ = TaskPrio::kLowLatency;\r\n  task_state_ = state_id;\r\n  method_ = Method::kCustom;\r\n  task_flags_.SetBits(TASK_UNORDERED | TASK_LANE_ANY);\r\n  domain_id_ = domain_id;\r\n\r\n  // Custom params\r\n  compress_method_ = compress_method;\r\n  HSHM_MAKE_AR(data_, alloc, data);\r\n}\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"lane_hash_"}),": The lane of the MultiQueue a request is keyed to if\r\nTASK_LANE_ANY is not set under the task flags. This gives concurrency control. Tasks in\r\nthe same lane will be executed sequentially if necessary."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"prio_"}),": The priority of the task. KLowLatency is priority 2."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"method_"}),": The method the task will be routed to by the runtime"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"task_flags_"}),": Various flags that can improve performance"]}),"\n"]}),"\n",(0,r.jsxs)(s.h3,{id:"modify-compresscc",children:["Modify ",(0,r.jsx)(s.code,{children:"compress.cc"})]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"void Compress(CompressTask *task, RunContext &rctx) {\r\n  task->SetModuleComplete();\r\n}\r\n\r\nvoid Decompress(DecompressTask *task, RunContext &rctx) {\r\n  task->SetModuleComplete();\r\n}\n"})}),"\n",(0,r.jsx)(s.p,{children:"Create the callback functions in the task server.\r\ntask->SetModuleComplete() indicates that the task is completely finished.\r\nLong-running tasks should not use this function."}),"\n",(0,r.jsxs)(s.h3,{id:"modify-compressh",children:["Modify ",(0,r.jsx)(s.code,{children:"compress.h"})]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"HSHM_ALWAYS_INLINE\r\nvoid AsyncCompressConstruct(CompressTask *task,\r\n                          const TaskNode &task_node,\r\n                          const DomainId &domain_id,\r\n                          int compress_method,\r\n                          const std::string &data) {\r\n  HRUN_CLIENT->ConstructTask<CompressTask>>(\r\n      task, task_node, domain_id, id_, compress_method, data);\r\n}\r\nHSHM_ALWAYS_INLINE\r\nvoid CompressRoot(const DomainId &domain_id,\r\n                  int compress_method,\r\n                  const std::string &data) {\r\n  LPointer<hrunpq::TypedPushTask<CompressTask>> task = AsyncCompressRoot(domain_id);\r\n  task.ptr_->Wait();\r\n}\r\nHRUN_TASK_NODE_PUSH_ROOT(Compress);\n"})}),"\n",(0,r.jsx)(s.p,{children:"CompressRoot will be called by clients directly.\r\nHRUN_TASK_NODE_PUSH_ROOT will create various helper methods that\r\neventually call AsyncCompressConstruct. LPointer is a struct that\r\ncontains a shared-memory pointer to a task and its corresponding\r\nprivate-memory pointer."}),"\n",(0,r.jsxs)(s.p,{children:["hrunpq::TypedPushTask represents a task that is stored inside of the\r\n",(0,r.jsx)(s.strong,{children:"process queue"}),". The process queue is a single-priority queue that\r\nconnects clients to the Hermes runtime. Tasks in this queue are keyed\r\nto lanes based on standard thread ID. This ensures that all tasks\r\noriginating from the same thread are in the same lane. This helps\r\ngive consistency guarantees for I/O operations."]}),"\n",(0,r.jsx)(s.h3,{id:"task-methods",children:"Task Methods"}),"\n",(0,r.jsx)(s.p,{children:"The task methods will be discussed in sections 6, 7, and 8."}),"\n",(0,r.jsx)(s.h2,{id:"registering-a-task-library",children:"Registering a Task Library"}),"\n",(0,r.jsx)(s.p,{children:"After creating a new task library, it must be registered with\r\nthe Hermes Runtime. This can be done either programmatically or\r\nthrough configuration."}),"\n",(0,r.jsxs)(s.p,{children:["Through configuration, you must edit the Hermes runtime configuration.\r\nAn example configuration is stored in ",(0,r.jsx)(s.code,{children:"${HERMES_ROOT}/config/hermes_server_default.yaml"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:'task_registry:\r\n  [\r\n    "hermes_mdm",\r\n    "hermes_blob_mdm",\r\n    "hermes_bucket_mdm",\r\n    "hermes_data_op",\r\n    "data_stager",\r\n    "posix_bdev",\r\n    "ram_bdev",\r\n    "compress",\r\n  ]\n'})}),"\n",(0,r.jsx)(s.p,{children:"This can be passed to the Hermes runtime using the HERMES_CONF environment\r\nvariable."}),"\n",(0,r.jsx)(s.h2,{id:"task-grouping-worker-polling-and-deadlock-prevention",children:"Task Grouping, Worker Polling, and Deadlock Prevention"}),"\n",(0,r.jsx)(s.p,{children:"This section will provide more insight on how queues are polled\r\nand processed in the Hermes Runtime to provide fine-grained control\r\nover scheduling and concurrency."}),"\n",(0,r.jsxs)(s.p,{children:["Tasks must all implement a function called ",(0,r.jsx)(s.code,{children:"GetGroup"}),". Task groups are used to enable look-ahead capabilities with safety. A ",(0,r.jsx)(s.strong,{children:"Task Group"})," represents a collection of tasks that modify the same metadata structure and need to be sequentially executed. For example, the Bucket ID is\r\nused as the group for calling the bucket methods GetSize and UpdateSize.\r\nThis ensures that GetSize and UpdateSize will be executed in sequence when\r\nmade to the same bucket. Certain operations do not require any synchronization (e.g., stateless methods) and can return a group of TASK_UNORDERED."]}),"\n",(0,r.jsxs)(s.p,{children:["A ",(0,r.jsx)(s.strong,{children:"Task Node"})," represents the location of a task in the overall\r\ntask graph. There is no Task Graph data structure, it's a concept.\r\nWhen a task spawns a subtask, it can be conceptually be considered\r\nas a task graph. Tasks apart of the same task graph will be executed\r\nsimultaneously --regardless of group -- to prevent deadlocks in the\r\ncase where two tasks from the same graph are keyed to the same queue and lane."]}),"\n",(0,r.jsx)(s.h2,{id:"building-a-replicatable-task",children:"Building a Replicatable Task"}),"\n",(0,r.jsx)(s.p,{children:"To make a task support replication, set the TF_REPLICA flag. This\r\nwill indicate that a task implements the replication methods."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-cpp",children:"struct CompressTask : public Task, TaskFlags<TF_SRL_SYM | TF_REPLICA> {\r\n  IN compress_type_;\r\n  IN hipc::ShmArchive<hipc::string> data_;\r\n  OUT hipc::ShmArchive<hipc::vector<size_t>> sizes_;\r\n  OUT size_t final_size_;\r\n\r\n  /** (De)serialize message call */\r\n  template<typename Ar>\r\n  void SerializeStart(Ar &ar) {\r\n    task_serialize<Ar>(ar);\r\n    ar(compress_type_, data_);\r\n  }\r\n\r\n  /** (De)serialize message return */\r\n  template<typename Ar>\r\n  void SerializeEnd(u32 replica, Ar &ar) {\r\n    ar(sizes_, final_size_);\r\n  }\r\n\r\n  /** Duplicate message */\r\n  void Dup(hipc::Allocator *alloc, CustomTask &other) {\r\n    task_dup(other);\r\n    compress_type_ = other.compress_type_;\r\n    HSHM_MAKE_AR(data_, alloc, other.data_);\r\n  }\r\n\r\n  /** Process duplicate message output */\r\n  void DupEnd(u32 replica, CustomTask &dup_task) {\r\n    (*sizes_)[repclica] = other.size_;\r\n  }\r\n\r\n  /** Begin replication */\r\n  void ReplicateStart(u32 count) {\r\n    size_->resize(count);\r\n  }\r\n\r\n  /** Finalize replication */\r\n  void ReplicateEnd() {\r\n    size_t final_size_ = std::numeric_limits<size_t>::min();\r\n    for (size_t &size : sizes_) {\r\n      if (final_size_ > size) {\r\n        final_size_ = size;\r\n      }\r\n    }\r\n  }\r\n};\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SerializeStart"}),": Will serialize and deserialize the ",(0,r.jsx)(s.em,{children:"input"})," parameters of the task. So anything labeled IN or INOUT."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"SerializeEnd"}),": Will serialize and deserialize the ",(0,r.jsx)(s.em,{children:"output"}),"\r\nparameters of the task. So anything labeled OUT or INOUT."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"Dup"}),": Analogous to a copy constructor. Will make a local\r\ncopy of this task (no serialization involved)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"DupEnd"}),": Will store the output of a replica in the original\r\ntask the duplicates were spawned from."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"ReplicateStart"}),": Used to allocate data structures in the task\r\nto account for the replication"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"ReplicateEnd"}),": Called after all replicas have returned. Can\r\naggregate replica otuput."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"building-a-data-intensive-rdma-capable-task",children:"Building a Data-Intensive, RDMA-Capable Task"}),"\n",(0,r.jsx)(s.p,{children:"TODO: Make example based on PutBlob and GetBlob."})]})}function h(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,s,n)=>{n.d(s,{Z:()=>o,a:()=>i});var r=n(7294);const t={},a=r.createContext(t);function i(e){const s=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(a.Provider,{value:s},e.children)}}}]);